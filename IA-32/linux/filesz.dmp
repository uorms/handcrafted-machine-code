# ELF HEADER

7F 45 4C 46  # ELF magic

01   # class (32-bit)
01   # endianess (LSB)
01   # ELF version
00   # OSABI
00   # OSABI version (or additional padding)

00 00 00 00 00 00 00  # padding

02 00        # e_type (ET_EXEC)
03 00        # e_machine
01 00 00 00  # e_version
54 80 04 08  # e_entry
34 00 00 00  # e_phoff
00 00 00 00  # e_shoff
00 00 00 00  # e_flags
34 00        # e_ehsize
20 00        # e_phentsize
01 00        # e_phnum
28 00        # e_shentsize
00 00        # e_shnum
00 00        # e_shstrndx

# PROGRAM HEADER (0x34)

01 00 00 00  # p_type 1=loadable segment
54 00 00 00  # file offset
54 80 04 08  # mem offset
00 00 00 00  # paddr
40 00 00 00  # filesz
40 00 00 00  # memsz
07 00 00 00  # flags (RWX)
00 00 00 00  # p_align

# PROGRAM SEGMENT (0x54)

# @write hello
B8 04 00 00 00  # eax <- 4
BB 01 00 00 00  # ebx <- 1
B9 C1 80 04 08  # ecx <- vaddr of string
BA 0E 00 00 00  # edx <- size of string
CD 80           # int 0x80

# @open file // file descriptor returned in eax
B8 05 00 00 00  # open
BB CF 80 04 08  # filename address
B9 00 00 00 00  # O_RDONLY
BA 00 00 00 00  # mode (don't know what this does)
CD 80

# save fd
50  # push eax

# @read file
B8 03 00 00 00  # read
8B FC           # edi <- esp
8B 5F 00        # ebx <- [edi+0]
B9 D3 80 04 08  # buf addr
BA 01 00 00 00  # count
CD 80

# @close file
B8 06 00 00 00  # close
5B              # pop ebx
CD 80

# @print buffer
B8 04 00 00 00
BB 01 00 00 00
B9 D3 80 04 08
BA 01 00 00 00
CD 80

# exit
B8 01 00 00 00
BB 00 00 00 00
CD 80

# @hello world  (0xC1)
48 65 6C 6C 6F
2C 20 57 6F 72
6C 64 21 0A

# @filename (0xCF)
41 42 43 00

# @buffer  189 (0xD3)
01 00 00 00
