# ELF HEADER

7F 45 4C 46  # ELF magic

01   # class (32-bit)
01   # endianess (LSB)
01   # ELF version
00   # OSABI
00   # OSABI version (or additional padding)

00 00 00 00 00 00 00  # padding

02 00        # e_type (ET_EXEC)
03 00        # e_machine
01 00 00 00  # e_version
54 80 04 08  # e_entry
34 00 00 00  # e_phoff
00 00 00 00  # e_shoff
00 00 00 00  # e_flags
34 00        # e_ehsize
20 00        # e_phentsize
01 00        # e_phnum
28 00        # e_shentsize
00 00        # e_shnum
00 00        # e_shstrndx

# PROGRAM HEADER (0x34)

01 00 00 00  # p_type 1=loadable segment
54 00 00 00  # file offset
54 80 04 08  # mem offset
00 00 00 00  # paddr
00 01 00 00  # filesz
00 01 00 00  # memsz
07 00 00 00  # flags (RWX)
00 00 00 00  # p_align

# PROGRAM SEGMENT (0x54)

# @open file // file descriptor returned in eax
B8 05 00 00 00  # open
BB D7 80 04 08  # filename address
B9 00 00 00 00  # O_RDONLY
BA 00 00 00 00  # mode (don't know what this does)
CD 80

# save fd
50  # push eax

# @read file
B8 03 00 00 00  # read
8B FC           # edi <- esp
8B 5F 00        # ebx <- [edi+0]
B9 DB 80 04 08  # buffer addr
BA 04 00 00 00  # count
CD 80

# @lseek file
B8 13 00 00 00 # eax <- lseek
B9 00 00 00 00 # ecx <- 0
BA 02 00 00 00 # edx <- SEEK_END?
CD 80
# result = eax <- file size

# @mov file size to buffer
BF DF 80 04 08 # buffer2 addr
89 47 00       # [edi+0] <- eax

# @print file size
B8 04 00 00 00 # eax <- 4 (write)
BB 01 00 00 00 # ebx <- 1 (stdout)
89 F9          # ecx <- edi
BA 04 00 00 00 # edx <- 1
CD 80

# @close file
B8 06 00 00 00  # close
5B              # pop ebx
CD 80

# @print buffer
B8 04 00 00 00
BB 01 00 00 00
B9 DB 80 04 08
BA 01 00 00 00
CD 80

# exit
B8 01 00 00 00 # 
BB 00 00 00 00 # 
CD 80          # D7

# @filename
41 42 43 00    # DB
# @buffer
DE AD BE EF    # DF
# @buffer2
FE AD CA BE    # E3

